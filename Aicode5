type KVPair = { key: string; value: string; depth: number };
type KVRow = { section: string; pairs: KVPair[] };


function objectToVerticalRows(
  obj: Record<string, any>,
  opts?: { maxDepth?: number }
): KVRow[] {
  const maxDepth = opts?.maxDepth ?? 6;

  const toPairs = (node: any, depth: number): KVPair[] => {
    if (depth > maxDepth) {
      return [{ key: "(value)", value: stringifyCell(node), depth }];
    }

    // array => keep as json string (or customize if you want)
    if (Array.isArray(node)) {
      return [{ key: "(list)", value: stringifyCell(node), depth }];
    }

    // primitive
    if (!isPlainObject(node)) {
      return [{ key: "(value)", value: stringifyCell(node), depth }];
    }

    const entries = Object.entries(node);
    if (!entries.length) return [{ key: "(empty)", value: "", depth }];

    const out: KVPair[] = [];

    for (const [k, v] of entries) {
      // If nested object, add a "header" row (key only), then children as deeper bullets
      if (isPlainObject(v)) {
        out.push({ key: k, value: "", depth }); // header line
        out.push(...toPairs(v, depth + 1).map(p => ({ ...p, depth: p.depth })));
      } else if (Array.isArray(v)) {
        out.push({ key: k, value: stringifyCell(v), depth });
      } else {
        out.push({ key: k, value: stringifyCell(v), depth });
      }
    }

    return out;
  };

  return Object.entries(obj).map(([section, node]) => ({
    section,
    pairs: isPlainObject(node)
      ? toPairs(node, 0)
      : [{ key: "(value)", value: stringifyCell(node), depth: 0 }],
  }));
}


function VerticalKVTable({ rows }: { rows: KVRow[] }) {
  // merged left cell counts
  const counts = rows.reduce<Record<string, number>>((acc, r) => {
    acc[r.section] = (acc[r.section] ?? 0) + 1;
    return acc;
  }, {});
  let lastSection: string | null = null;

  return (
    <div className="overflow-auto rounded-md border border-stone-200 bg-white">
      <table className="w-full border-collapse text-sm">
        <tbody>
          {rows.map((r, idx) => {
            const firstOfSection = r.section !== lastSection;
            if (firstOfSection) lastSection = r.section;

            return (
              <tr key={idx} className="align-top border-b border-stone-200">
                {/* LEFT merged cell */}
                {firstOfSection ? (
                  <td
                    rowSpan={counts[r.section]}
                    className="w-[32%] align-top border-r border-stone-200 bg-stone-50 p-3 font-semibold text-stone-800"
                  >
                    {normalizeText(r.section)}
                  </td>
                ) : null}

                {/* RIGHT big cell with bullets */}
                <td className="align-top p-3 text-stone-900">
                  <ul className="space-y-2">
                    {r.pairs.map((p, i) => {
                      const isHeaderOnly = p.value === "";
                      return (
                        <li
                          key={i}
                          style={{ marginLeft: `${p.depth * 14}px` }} // indentation
                          className="leading-5"
                        >
                          {/* bullet + key */}
                          <div className="flex gap-2">
                            <span className="mt-[6px] h-1.5 w-1.5 rounded-full bg-stone-400 shrink-0" />
                            <div className="min-w-0">
                              <div className="font-medium text-stone-800">
                                {normalizeText(p.key)}
                                {!isHeaderOnly ? ":" : ""}
                              </div>

                              {/* value only when present */}
                              {!isHeaderOnly ? (
                                <div className="text-stone-900 whitespace-pre-wrap">
                                  {normalizeText(p.value)}
                                </div>
                              ) : null}
                            </div>
                          </div>
                        </li>
                      );
                    })}
                  </ul>
                </td>
              </tr>
            );
          })}
        </tbody>
      </table>
    </div>
  );
}


<VerticalKVTable rows={objectToVerticalRows(objValue)} />


function EvidenceList({
  evSorted,
  f,
  jump,
  onHighlightEvidence,
}: {
  evSorted: any[];
  f: any;
  jump: (p: number) => void;
  onHighlightEvidence?: (x: { page: number; phrases: string[] }) => void;
}) {
  if (!evSorted.length) return null;

  return (
    <div className="mt-4 space-y-3">
      <div className="text-xs font-semibold text-stone-700 flex items-center gap-1">
        <Info className="h-3.5 w-3.5 text-emerald-700" />
        Evidence
      </div>

      {evSorted.map((ev, eidx) => (
        <button
          key={ev.id ?? `${f.id}_ev_${eidx}`}
          type="button"
          onClick={() => {
            const p = ev.page ?? f.page;
            if (typeof p === "number" && p > 0) {
              onHighlightEvidence?.({ page: p, phrases: [ev.snippet ?? ""] });
              jump(p);
            }
          }}
          className="w-full text-left rounded-md border border-stone-200 bg-white p-2 hover:border-emerald-200 hover:bg-emerald-50/30 transition"
          title={typeof (ev.page ?? f.page) === "number" ? `Jump to page ${ev.page ?? f.page}` : undefined}
        >
          <div className="flex items-center gap-2 mb-1 flex-wrap">
            {typeof (ev.page ?? f.page) === "number" ? (
              <Badge>Page {ev.page ?? f.page}</Badge>
            ) : null}
            {ev.id ? <Badge>ID: {ev.id.slice(0, 8)}…</Badge> : null}
          </div>

          {ev.snippet ? (
            <div className="text-sm text-stone-900 whitespace-pre-wrap leading-5">
              {normalizeText(ev.snippet)}
            </div>
          ) : null}

          {/* ✅ References ALWAYS show when present */}
          {ev.page_markdown ? (
            <details className="mt-2" onClick={(e) => e.stopPropagation()}>
              <summary className="cursor-pointer text-xs text-emerald-700 hover:text-emerald-800 inline-flex items-center gap-1">
                <BookOpenText className="h-3.5 w-3.5" />
                References
              </summary>
              <div className="mt-2 text-xs whitespace-pre-wrap text-stone-700 bg-yellow-50 border border-stone-200 rounded-md p-2 overflow-auto leading-5">
                {normalizeText(ev.page_markdown)}
              </div>
            </details>
          ) : null}
        </button>
      ))}
    </div>
  );
}

<EvidenceList
  evSorted={evSorted}
  f={f}
  jump={jump}
  onHighlightEvidence={onHighlightEvidence}
/>

<EvidenceList
  evSorted={evSorted}
  f={f}
  jump={jump}
  onHighlightEvidence={onHighlightEvidence}
/>


<EvidenceList
  evSorted={evSorted}
  f={f}
  jump={jump}
  onHighlightEvidence={onHighlightEvidence}
/>



