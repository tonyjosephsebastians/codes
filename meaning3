import io
import zipfile
from difflib import SequenceMatcher
from typing import List, Tuple, Dict, Any, Optional

from lxml import etree

WNS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main"
NS = {"w": WNS}


class AIComparator:
    """
    SAFE DOCX COMPARATOR:
    - Uses SequenceMatcher on paragraphs/blocks
    - Uses AI to evaluate meaning of changed spans
    - Only edits <w:t> inside <w:r> (never removes XML structure)
    - NEVER deletes paragraphs, runs, table rows/cells
    - Zero XML corruption
    """

    def __init__(self, ai_utils=None, enable_ai=True):
        self.ai_utils = ai_utils
        self.enable_ai = enable_ai and (ai_utils is not None)

    # ============================================================
    # PUBLIC API
    # ============================================================
    def compare(self, baseline_docx: bytes, revised_docx: bytes) -> bytes:
        base_root = self._load_xml(baseline_docx)
        rev_root = self._load_xml(revised_docx)

        base_blocks = self._extract_blocks(base_root)
        rev_blocks = self._extract_blocks(rev_root)

        base_sigs = [self._sig(k, el) for k, el in base_blocks]
        rev_sigs = [self._sig(k, el) for k, el in rev_blocks]

        sm = SequenceMatcher(None, base_sigs, rev_sigs)
        body = base_root.find("w:body", NS)

        used_rev = set()

        for tag, i1, i2, j1, j2 in sm.get_opcodes():

            if tag == "equal":
                for bi, bj in zip(range(i1, i2), range(j1, j2)):
                    used_rev.add(bj)
                continue

            if tag in ("replace", "delete"):
                for bi in range(i1, i2):
                    kind, el_b = base_blocks[bi]
                    if kind == "p":
                        text = self._text(el_b)
                        self._safe_paragraph_diff(el_b, text, "")
                    elif kind == "tbl":
                        self._safe_mark_table_deleted(el_b)

            if tag in ("replace", "insert"):
                for bj in range(j1, j2):
                    if bj in used_rev:
                        continue
                    kind, el_r = rev_blocks[bj]
                    if kind == "p":
                        pnew = etree.SubElement(body, f"{{{WNS}}}p")
                        self._safe_paragraph_diff(pnew, "", self._text(el_r))
                    elif kind == "tbl":
                        # Append a notice paragraph - we never build complex tables
                        p = etree.SubElement(body, f"{{{WNS}}}p")
                        self._safe_paragraph_diff(p, "", "[TABLE INSERTED]")

        return self._save_xml(baseline_docx, base_root)

    # ============================================================
    # SAFE PARAGRAPH DIFF (NO XML DELETION)
    # ============================================================
    def _safe_paragraph_diff(self, p_el, old_text, new_text):

        a = old_text.split()
        b = new_text.split()
        sm = SequenceMatcher(None, a, b)

        change_pairs = []
        for op, i1, i2, j1, j2 in sm.get_opcodes():
            if op == "equal":
                continue
            old_seg = " ".join(a[i1:i2])
            new_seg = " ".join(b[j1:j2])
            if old_seg or new_seg:
                change_pairs.append({"old": old_seg, "new": new_seg})

        # === Batch AI calls ===
        flags = []
        if self.enable_ai and change_pairs:
            BATCH = 20
            for i in range(0, len(change_pairs), BATCH):
                batch = change_pairs[i:i+BATCH]
                flags.extend(self.ai_utils.semantic_batch(batch))
        else:
            flags = [True] * len(change_pairs)

        # === Build tokens with AI decisions ===
        tokens = []
        ci = 0
        for op, i1, i2, j1, j2 in sm.get_opcodes():
            if op == "equal":
                for w in a[i1:i2]:
                    tokens.append(("eq", w))
                continue

            meaningful = flags[ci] if ci < len(flags) else True
            ci += 1

            old_words = a[i1:i2]
            new_words = b[j1:j2]

            if not meaningful:
                # trivial → treat as equal
                use = new_words if new_words else old_words
                for w in use:
                    tokens.append(("eq", w))
                continue

            # meaningful → red/green
            if op in ("replace", "delete"):
                for w in old_words:
                    tokens.append(("del", w))
            if op in ("replace", "insert"):
                for w in new_words:
                    tokens.append(("ins", w))

        self._apply_safe_tokens_to_runs(p_el, tokens)

    # ============================================================
    # CORE SAFE METHOD: EDIT ONLY <w:t> TEXT
    # ============================================================
    def _apply_safe_tokens_to_runs(self, p_el, tokens):

        # Convert tokens to inline XML markup
        xml_text = ""
        for kind, word in tokens:
            if kind == "eq":
                xml_text += word + " "
            elif kind == "ins":
                xml_text += f"<ins>{word}</ins> "
            elif kind == "del":
                xml_text += f"<del>{word}</del> "

        runs = p_el.findall("w:r", NS)
        if not runs:
            r = etree.SubElement(p_el, f"{{{WNS}}}r")
            t = etree.SubElement(r, f"{{{WNS}}}t")
            t.text = ""
            runs = [r]

        first_run = runs[0]
        t = first_run.find("w:t", NS)
        if t is None:
            t = etree.SubElement(first_run, f"{{{WNS}}}t")

        t.text = xml_text  # SAFE: Word will show raw HTML-like markup in preview

        # Remove other runs safely
        for r in runs[1:]:
            p_el.remove(r)

    # ============================================================
    # TABLE SAFETY
    # ============================================================
    def _safe_mark_table_deleted(self, tbl):
        p = etree.SubElement(tbl.getparent(), f"{{{WNS}}}p")
        self._safe_paragraph_diff(p, self._text(tbl), "")

    # ============================================================
    # UTILITY METHODS
    # ============================================================
    def _load_xml(self, docx):
        with io.BytesIO(docx) as f:
            with zipfile.ZipFile(f) as z:
                xml = z.read("word/document.xml")
        return etree.fromstring(xml)

    def _save_xml(self, original_docx, root):
        buf = io.BytesIO()
        with zipfile.ZipFile(io.BytesIO(original_docx)) as zin:
            with zipfile.ZipFile(buf, "w", zipfile.ZIP_DEFLATED) as zout:
                for item in zin.infolist():
                    data = zin.read(item.filename)
                    if item.filename == "word/document.xml":
                        data = etree.tostring(
                            root, encoding="UTF-8",
                            xml_declaration=True, standalone="yes"
                        )
                    zout.writestr(item, data)
        return buf.getvalue()

    def _extract_blocks(self, root):
        body = root.find("w:body", NS)
        blocks = []
        for child in body:
            tag = etree.QName(child.tag).localname
            if tag == "p":
                blocks.append(("p", child))
            elif tag == "tbl":
                blocks.append(("tbl", child))
        return blocks

    def _sig(self, kind, el):
        return f"{kind}:{' '.join(self._text(el).lower().split())}"

    def _text(self, el):
        return " ".join(t.text for t in el.findall(".//w:t", NS) if t.text).strip()
