<div id={`pdf-page-${i + 1}`} className="scroll-mt-4">
  <PDFPage ... />
</div>


type HighlightPayload = {
  page: number;
  phrases: string[];     // one or many phrases
  mode?: "phrase";       // keep room for future modes
};

function normalize(s: string) {
  return s
    .replace(/\u00AD/g, "")           // soft hyphen
    .replace(/\s+/g, " ")            // collapse whitespace
    .replace(/-\s+/g, "")            // join hyphen line breaks: "confi-\n dential" => "confidential"
    .trim()
    .toLowerCase();
}

function escapeRegExp(s: string) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

function clearHighlightOverlays(pageWrap: HTMLElement) {
  pageWrap.querySelectorAll(".pdf-hl-overlay").forEach((n) => n.remove());
}

function getTextNodesInOrder(root: HTMLElement) {
  const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT);
  const nodes: Text[] = [];
  let n: Node | null;
  while ((n = walker.nextNode())) nodes.push(n as Text);
  return nodes;
}

/**
 * Build a "raw" concatenation of all text nodes AND a normalized version,
 * plus mapping normalizedIndex -> rawIndex so we can convert exact matches back.
 */
function buildIndex(textNodes: Text[]) {
  let raw = "";
  const parts: { node: Text; start: number; end: number }[] = [];

  for (const node of textNodes) {
    const t = node.nodeValue ?? "";
    const start = raw.length;
    raw += t;
    const end = raw.length;
    parts.push({ node, start, end });
    raw += " "; // spacer between nodes to avoid word-sticking
  }

  const rawLower = raw.toLowerCase();

  // Build normalized string + map normIdx -> rawIdx
  let norm = "";
  const map: number[] = [];

  // Normalize by scanning rawLower; collapse whitespace; remove "- " hyphen breaks
  for (let i = 0; i < rawLower.length; i++) {
    const ch = rawLower[i];

    // remove soft hyphen
    if (ch === "\u00ad") continue;

    // join "- " (hyphen + whitespace) => remove both
    if (ch === "-" && i + 1 < rawLower.length && /\s/.test(rawLower[i + 1])) {
      // skip "-" and following spaces
      let j = i + 1;
      while (j < rawLower.length && /\s/.test(rawLower[j])) j++;
      i = j - 1;
      continue;
    }

    // collapse whitespace
    if (/\s/.test(ch)) {
      if (norm.length === 0) continue;
      if (norm[norm.length - 1] === " ") continue;
      norm += " ";
      map.push(i);
      continue;
    }

    norm += ch;
    map.push(i);
  }

  return { raw, rawLower, norm, map, parts };
}

function findAllMatches(haystack: string, needle: string) {
  const out: { start: number; end: number }[] = [];
  if (!needle) return out;

  // exact phrase match (normalized)
  const re = new RegExp(`\\b${escapeRegExp(needle)}\\b`, "g"); // word-bounded
  let m: RegExpExecArray | null;
  while ((m = re.exec(haystack))) out.push({ start: m.index, end: m.index + m[0].length });

  // fallback if no word-boundary match (phrases may include punctuation)
  if (out.length === 0) {
    let idx = 0;
    while (true) {
      const pos = haystack.indexOf(needle, idx);
      if (pos === -1) break;
      out.push({ start: pos, end: pos + needle.length });
      idx = pos + Math.max(1, Math.floor(needle.length / 3));
    }
  }

  return out;
}

function rangeFromRawIndices(
  parts: { node: Text; start: number; end: number }[],
  rawStart: number,
  rawEnd: number
) {
  // locate start node
  const startPart = parts.find(p => rawStart >= p.start && rawStart <= p.end);
  const endPart = parts.find(p => rawEnd >= p.start && rawEnd <= p.end);
  if (!startPart || !endPart) return null;

  const range = document.createRange();
  range.setStart(startPart.node, Math.max(0, rawStart - startPart.start));
  range.setEnd(endPart.node, Math.max(0, rawEnd - endPart.start));
  return range;
}

function addOverlayRects(pageWrap: HTMLElement, rects: DOMRectList) {
  const wrapRect = pageWrap.getBoundingClientRect();

  for (const r of Array.from(rects)) {
    // ignore tiny rects (noise)
    if (r.width < 2 || r.height < 6) continue;

    const hl = document.createElement("div");
    hl.className = "pdf-hl-overlay";
    hl.style.position = "absolute";
    hl.style.left = `${r.left - wrapRect.left}px`;
    hl.style.top = `${r.top - wrapRect.top}px`;
    hl.style.width = `${r.width}px`;
    hl.style.height = `${r.height}px`;
    hl.style.background = "rgba(253, 224, 71, 0.45)"; // yellow
    hl.style.borderRadius = "4px";
    hl.style.pointerEvents = "none";
    hl.style.boxShadow = "0 0 0 2px rgba(253, 224, 71, 0.20)";
    pageWrap.appendChild(hl);
  }
}

function highlightPhrasesOnPage(pageWrap: HTMLElement, phrases: string[]) {
  const textLayer = pageWrap.querySelector<HTMLElement>(".react-pdf__Page__textContent");
  if (!textLayer) return;

  // pageWrap must be positioned so absolute overlays work
  pageWrap.style.position = "relative";

  clearHighlightOverlays(pageWrap);

  const textNodes = getTextNodesInOrder(textLayer);
  const idx = buildIndex(textNodes);

  for (const p of phrases) {
    const needle = normalize(p);
    if (!needle || needle.length < 6) continue; // avoid junk matches

    const matches = findAllMatches(idx.norm, needle).slice(0, 8); // cap per phrase
    for (const m of matches) {
      const rawStart = idx.map[m.start] ?? 0;
      const rawEnd = idx.map[m.end - 1] ?? rawStart;

      const range = rangeFromRawIndices(idx.parts, rawStart, rawEnd + 1);
      if (!range) continue;

      const rects = range.getClientRects();
      addOverlayRects(pageWrap, rects);
    }
  }
}



const [highlight, setHighlight] = React.useState<HighlightPayload | null>(null);

React.useEffect(() => {
  if (!highlight?.page || !highlight.phrases?.length) return;

  // wait for text layer to exist
  const raf = requestAnimationFrame(() => {
    const wrap = document.getElementById(`pdf-page-${highlight.page}`);
    if (!wrap) return;
    highlightPhrasesOnPage(wrap, highlight.phrases);
  });

  return () => cancelAnimationFrame(raf);
}, [highlight]);


onHighlightEvidence?.({
  page: p,
  phrases: [ev.snippet ?? ""],
});


<ExtractionPanel
  extractionRun={extractionRun}
  onJumpToPage={jumpToPdfPage}
  onHighlightEvidence={(payload) => setHighlight(payload)}
/>


function TablePreview({
  table,
  page,
  onHighlight,
}: {
  table: TableItem;
  page?: number;
  onHighlight?: (payload: HighlightPayload) => void;
}) {


<tbody>
  {previewRows.map((r, idx) => {
    const phrases = cols
      .map((c) => (r?.[c] ?? ""))
      .map((v) => (typeof v === "string" ? v : JSON.stringify(v)))
      .map((s) => s.trim())
      .filter((s) => s.length >= 6)
      .slice(0, 8);

    return (
      <tr
        key={idx}
        className="border-b border-stone-100 hover:bg-amber-50 cursor-pointer"
        onClick={() => {
          if (typeof page === "number" && page > 0 && phrases.length) {
            onHighlight?.({ page, phrases });
          }
        }}
        title="Click to highlight this row on the PDF"
      >
        {cols.map((c) => (
          <td key={c} className="px-2 py-2 text-stone-800 align-top">
            {typeof r?.[c] === "string" ? r[c] : JSON.stringify(r?.[c] ?? "")}
          </td>
        ))}
      </tr>
    );
  })}
</tbody>

<TablePreview
  table={t}
  page={t.source_page}
  onHighlight={(payload) => {
    setHighlight(payload);
    if (typeof payload.page === "number") jumpToPdfPage(payload.page);
  }}
/>


