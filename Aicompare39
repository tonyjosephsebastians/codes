import React, { useEffect, useRef, useState, useCallback } from "react";
import { Loader2 } from "lucide-react";
import { renderAsync } from "docx-preview";
import { aiCompareApi } from "@/services/api";

interface WordDocumentPreviewProps {
  file?: File;
  fileUrl?: string;
  arrayBuffer?: ArrayBuffer;
  baselineArrayBuffer?: ArrayBuffer | null;
  fileName?: string;

  onScroll?: (scrollTop: number, scrollLeft: number) => void;
  scrollTop?: number;
  scrollLeft?: number;
  syncScroll?: boolean;

  showDiff?: boolean;
  activeClauseReference?: string | null;
}

const WordDocumentPreview: React.FC<WordDocumentPreviewProps> = ({
  file,
  fileUrl,
  arrayBuffer,
  baselineArrayBuffer,
  fileName,

  onScroll,
  scrollTop = 0,
  scrollLeft = 0,
  syncScroll = false,

  showDiff = false,
  activeClauseReference = null,
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const scrollContainerRef = useRef<HTMLDivElement>(null);

  const isRenderingRef = useRef(false);
  const isSyncingRef = useRef(false);

  // Prevent sync-scroll from fighting clause-scroll
  const pauseSyncScrollRef = useRef(false);
  const clauseScrollLockRef = useRef(false);

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  /* -------------------------------------------------- */
  /* Text helpers                                       */
  /* -------------------------------------------------- */

  const normalize = useCallback((t: string) => {
    return (t || "")
      .toLowerCase()
      .replace(/\u00a0/g, " ") // NBSP
      .replace(/\s+/g, " ")
      .replace(/[^\w\s().,-]/g, "") // keep basic punctuation
      .trim();
  }, []);

  const normalizeNoSpace = useCallback((t: string) => {
    // for cases where docx preview renders "wordsstucktogether"
    return normalize(t).replace(/\s+/g, "");
  }, [normalize]);

  const toBase64 = (buf: ArrayBuffer) =>
    btoa(String.fromCharCode(...new Uint8Array(buf)));

  async function fetchWordDiff(baseline: ArrayBuffer, revised: ArrayBuffer) {
    const res = await aiCompareApi.compareDocuments(
      toBase64(baseline),
      toBase64(revised)
    );

    if (!res?.diff_docx_b64) throw new Error("Invalid diff response");

    return Uint8Array.from(atob(res.diff_docx_b64), (c) => c.charCodeAt(0))
      .buffer;
  }

  /* -------------------------------------------------- */
  /* Find the REAL scroll host                          */
  /* -------------------------------------------------- */

  const getScrollHost = useCallback((startEl: HTMLElement): HTMLElement | null => {
    // Prefer our known scroll container if it actually scrolls
    const preferred = scrollContainerRef.current;
    if (preferred && preferred.scrollHeight > preferred.clientHeight) return preferred;

    // Otherwise walk up from the match element to find the first scrollable ancestor
    let el: HTMLElement | null = startEl;
    while (el) {
      const style = window.getComputedStyle(el);
      const overflowY = style.overflowY;
      const canScrollY =
        (overflowY === "auto" || overflowY === "scroll") &&
        el.scrollHeight > el.clientHeight;

      if (canScrollY) return el;
      el = el.parentElement;
    }

    return preferred || null;
  }, []);

  /* -------------------------------------------------- */
  /* Build clean text for diff-safe matching             */
  /* -------------------------------------------------- */

  const buildCleanTextForMatch = useCallback((node: HTMLElement) => {
    // Clone so we can strip deletions safely
    const clone = node.cloneNode(true) as HTMLElement;

    // Remove <del> blocks (common in redlines)
    clone.querySelectorAll("del").forEach((el) => el.remove());

    // Remove known delete classes (if your diff uses them)
    clone
      .querySelectorAll(".word-delete, [data-diff='delete'], .diff-delete")
      .forEach((el) => el.remove());

    // Remove anything that is visually line-through (docx-preview sometimes does inline styles)
    clone.querySelectorAll("*").forEach((el) => {
      const style = (el as HTMLElement).style;
      // inline style check
      if (style?.textDecorationLine?.includes("line-through")) {
        el.remove();
        return;
      }
      // computed style check (heavier but reliable)
      const cs = window.getComputedStyle(el as HTMLElement);
      if (cs.textDecorationLine.includes("line-through")) {
        el.remove();
      }
    });

    // KEEP inserts. (No removal of <ins> or .word-insert)
    const raw = (clone.innerText || clone.textContent || "").trim();
    return raw;
  }, []);

  /* -------------------------------------------------- */
  /* Render DOCX                                        */
  /* -------------------------------------------------- */

  useEffect(() => {
    const renderDocument = async () => {
      if (isRenderingRef.current || !containerRef.current) return;
      isRenderingRef.current = true;

      try {
        setLoading(true);
        setError(null);

        let data: ArrayBuffer | undefined;

        if (arrayBuffer) data = arrayBuffer;
        else if (file) data = await file.arrayBuffer();
        else if (fileUrl) {
          const r = await fetch(fileUrl);
          data = await r.arrayBuffer();
        }

        if (!data) return;

        containerRef.current.innerHTML = "";

        const wrapper = document.createElement("div");
        wrapper.className = "docx-wrapper";
        containerRef.current.appendChild(wrapper);

        let renderBuffer = data;

        if (showDiff && baselineArrayBuffer && arrayBuffer) {
          renderBuffer = await fetchWordDiff(baselineArrayBuffer, arrayBuffer);
        }

        await renderAsync(renderBuffer, wrapper, undefined, {
          breakPages: true,
          ignoreWidth: false,
          ignoreHeight: false,
          renderHeaders: true,
          renderFooters: true,
          renderEndnotes: true,
        });

        // Styles: remove shadows + prevent horizontal scroll + keep nice centering
        const style = document.createElement("style");
        style.textContent = `
          section.docx {
            box-shadow: none !important;
            border: none !important;
            background: white !important;
          }
          .docx-wrapper {
            background: white !important;
            padding: 0 !important;
            width: 100% !important;
            overflow-x: hidden !important;
          }
          /* Make pages fit container without horizontal scrollbar */
          .docx-wrapper > section.docx {
            max-width: 100% !important;
            margin: 0 auto !important;
          }
          .docx-wrapper img,
          .docx-wrapper table {
            max-width: 100% !important;
          }

          .active-clause {
            background: rgba(255, 235, 59, 0.45) !important;
            border-radius: 4px;
          }
        `;
        containerRef.current.appendChild(style);
      } catch (e: any) {
        setError(e?.message || "Failed to render document");
      } finally {
        setLoading(false);
        isRenderingRef.current = false;
      }
    };

    renderDocument();

    return () => {
      if (containerRef.current) containerRef.current.innerHTML = "";
    };
  }, [arrayBuffer, baselineArrayBuffer, showDiff, fileUrl, file]);

  /* -------------------------------------------------- */
  /* Clause highlight + reliable scroll (diff-safe)      */
  /* -------------------------------------------------- */

  useEffect(() => {
    if (!activeClauseReference || !containerRef.current) return;

    // Wait a tick so docx-preview DOM is fully present
    const t = window.setTimeout(() => {
      const root = containerRef.current!;
      const targetNorm = normalize(activeClauseReference);
      const targetNoSpace = normalizeNoSpace(activeClauseReference);

      // Search in paragraphs, list items, and table cells
      const nodes = Array.from(
        root.querySelectorAll("p, li, td, th")
      ) as HTMLElement[];

      let match: HTMLElement | null = null;

      for (const node of nodes) {
        const cleanRaw = buildCleanTextForMatch(node);
        const cleanNorm = normalize(cleanRaw);
        const cleanNoSpace = normalizeNoSpace(cleanRaw);

        // Strong match (normal)
        if (cleanNorm.includes(targetNorm.slice(0, Math.min(40, targetNorm.length)))) {
          match = node;
          break;
        }

        // Fallback for “textWithoutSpaces” rendering
        if (cleanNoSpace.includes(targetNoSpace.slice(0, Math.min(25, targetNoSpace.length)))) {
          match = node;
          break;
        }
      }

      if (!match) {
        console.warn("Clause not found:", activeClauseReference);
        return;
      }

      // Remove old highlight
      root.querySelectorAll(".active-clause").forEach((el) => {
        el.classList.remove("active-clause");
      });
      match.classList.add("active-clause");

      // Clause scroll lock to prevent sync-scroll fighting it
      clauseScrollLockRef.current = true;
      pauseSyncScrollRef.current = true;
      isSyncingRef.current = true;

      const host = getScrollHost(match);
      if (!host) return;

      // ✅ RELIABLE scroll using rect delta (works inside docx-preview)
      const hostRect = host.getBoundingClientRect();
      const matchRect = match.getBoundingClientRect();

      // move so the match is ~25% from top (nice reading)
      const desiredTop = host.scrollTop + (matchRect.top - hostRect.top) - host.clientHeight * 0.25;

      host.scrollTo({
        top: Math.max(0, desiredTop),
        behavior: "smooth",
      });

      // After scroll settles, release locks and broadcast position for the other pane
      window.setTimeout(() => {
        try {
          onScroll?.(host.scrollTop, host.scrollLeft);
        } finally {
          isSyncingRef.current = false;
          clauseScrollLockRef.current = false;
          pauseSyncScrollRef.current = false;
        }
      }, 450);
    }, 50);

    return () => window.clearTimeout(t);
  }, [
    activeClauseReference,
    showDiff,
    normalize,
    normalizeNoSpace,
    buildCleanTextForMatch,
    getScrollHost,
    onScroll,
  ]);

  /* -------------------------------------------------- */
  /* Sync Scroll (more stable)                           */
  /* -------------------------------------------------- */

  useEffect(() => {
    if (!syncScroll) return;
    const host = scrollContainerRef.current;
    if (!host) return;

    // If a clause scroll is happening, do not fight it
    if (pauseSyncScrollRef.current || clauseScrollLockRef.current) return;
    if (isSyncingRef.current) return;

    isSyncingRef.current = true;

    requestAnimationFrame(() => {
      host.scrollTop = scrollTop;
      host.scrollLeft = scrollLeft;

      window.setTimeout(() => {
        isSyncingRef.current = false;
      }, 16);
    });
  }, [scrollTop, scrollLeft, syncScroll]);

  const handleScroll = (e: React.UIEvent<HTMLDivElement>) => {
    if (!onScroll) return;
    if (isSyncingRef.current) return;
    if (pauseSyncScrollRef.current || clauseScrollLockRef.current) return;

    const t = e.currentTarget;
    onScroll(t.scrollTop, t.scrollLeft);
  };

  /* -------------------------------------------------- */
  /* UI                                                 */
  /* -------------------------------------------------- */

  return (
    <div className="flex flex-col h-full bg-white">
      {loading && (
        <div className="flex flex-col items-center justify-center h-full">
          <Loader2 className="h-10 w-10 animate-spin text-[#007C41]" />
          <p className="text-sm text-gray-600 mt-2">Loading document…</p>
        </div>
      )}

      {error && (
        <div className="flex flex-col items-center justify-center h-full">
          <p className="text-red-600 font-semibold">Error rendering document</p>
          <p className="text-sm text-gray-500">{error}</p>
        </div>
      )}

      <div
        ref={scrollContainerRef}
        className="flex-1 overflow-y-auto overflow-x-hidden bg-gray-50"
        onScroll={handleScroll}
      >
        <div
          ref={containerRef}
          className={`docx-container ${loading || error ? "hidden" : ""}`}
          style={{ minHeight: "100%", width: "100%" }}
        />
      </div>

      {fileName && (
        <div className="text-xs text-gray-500 text-center border-t p-1">
          {fileName}
        </div>
      )}
    </div>
  );
};

export default WordDocumentPreview;
