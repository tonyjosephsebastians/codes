import re
import json
import tempfile
from pathlib import Path
from datetime import datetime
from typing import Any, Dict, List, Optional

from fastapi import Depends, HTTPException, BackgroundTasks
from fastapi.responses import FileResponse

# python-docx
from docx import Document as DocxDocument
from docx.shared import Inches

# --- DOCX safety: remove characters that can corrupt Word ---
# XML 1.0 valid chars: https://www.w3.org/TR/xml/#charsets
_XML10_INVALID_RE = re.compile(
    r"["

    # 0x00-0x08, 0x0B, 0x0C, 0x0E-0x1F are invalid
    r"\x00-\x08\x0B\x0C\x0E-\x1F"

    # surrogates (often appear if text is messed up)
    r"\uD800-\uDFFF"

    # noncharacters
    r"\uFFFE\uFFFF"
    r"]"
)

def safe_text(value: Any) -> str:
    """
    Convert anything to safe string for DOCX (prevents Word corruption).
    """
    if value is None:
        return ""
    if isinstance(value, (dict, list)):
        s = json.dumps(value, ensure_ascii=False)
    else:
        s = str(value)

    # normalize newlines
    s = s.replace("\r\n", "\n").replace("\r", "\n")

    # remove invalid XML chars
    s = _XML10_INVALID_RE.sub(" ", s)

    # also remove any remaining control chars except \n and \t
    s = "".join(ch if (ch == "\n" or ch == "\t" or ord(ch) >= 32) else " " for ch in s)

    # avoid huge runs that can bloat docs
    return s.strip()

def add_kv_table(doc: DocxDocument, rows: List[List[str]]) -> None:
    table = doc.add_table(rows=len(rows), cols=2)
    table.style = "Table Grid"
    for i, (k, v) in enumerate(rows):
        table.cell(i, 0).text = safe_text(k)
        table.cell(i, 1).text = safe_text(v)

def add_simple_table(doc: DocxDocument, title: str, columns: List[str], rows: List[List[Any]]) -> None:
    doc.add_paragraph()
    doc.add_heading(safe_text(title), level=2)

    if not columns:
        doc.add_paragraph("No columns found.")
        return

    table = doc.add_table(rows=1, cols=len(columns))
    table.style = "Table Grid"

    hdr = table.rows[0].cells
    for j, c in enumerate(columns):
        hdr[j].text = safe_text(c)

    for r in rows:
        tr = table.add_row().cells
        for j in range(len(columns)):
            tr[j].text = safe_text(r[j] if j < len(r) else "")

def cleanup_file(path: str) -> None:
    try:
        Path(path).unlink(missing_ok=True)
    except Exception:
        pass


# ---------------------------
# YOUR ROUTE (replace yours)
# ---------------------------
@router.get("/documents/{doc_id}/report")
def generate_docx_report(
    doc_id: str,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db),
    current_user=Depends(get_current_user),
):
    # 1) Find document
    doc_obj = db.query(Document).filter(Document.id == doc_id).first()
    if not doc_obj:
        raise HTTPException(status_code=404, detail="Document not found")

    # 2) Permissions (keep your existing logic)
    # if not allowed: raise HTTPException(403, ...)

    # 3) Load latest extraction run (use YOUR function)
    run = _get_latest_completed_run(db=db, document_id=doc_id, username=current_user.username, standard="SOC2")
    if not run:
        raise HTTPException(status_code=404, detail="No completed extraction run found for this document")

    # 4) Build DOCX safely
    doc = DocxDocument()
    for section in doc.sections:
        section.top_margin = Inches(1)
        section.bottom_margin = Inches(1)
        section.left_margin = Inches(1)
        section.right_margin = Inches(1)

    doc.add_heading("SOC2 Extraction Report", level=0)
    doc.add_paragraph(safe_text(getattr(doc_obj, "original_filename", doc_id)))

    # metadata
    add_kv_table(doc, [
        ["Document ID", doc_id],
        ["Extraction Run ID", safe_text(getattr(run, "id", ""))],
        ["Standard", safe_text(getattr(run, "standard", "SOC2"))],
        ["Generated (UTC)", datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")],
        ["Generated By", safe_text(getattr(current_user, "username", ""))],
    ])

    # fields (IMPORTANT: sanitize all extracted values/snippets)
    doc.add_paragraph()
    doc.add_heading("Extracted Fields", level=1)

    fields = getattr(run, "fields", None) or []
    if not fields:
        doc.add_paragraph("No fields found.")
    else:
        for f in fields:
            field_name = safe_text(getattr(f, "field_name", ""))
            value = safe_text(getattr(f, "value", ""))
            confidence = safe_text(getattr(f, "confidence", ""))
            page = safe_text(getattr(f, "page", ""))
            snippet = safe_text(getattr(f, "source_snippet", ""))

            doc.add_heading(field_name or "Field", level=2)
            add_kv_table(doc, [
                ["Value", value],
                ["Confidence", confidence],
                ["Page", page],
            ])
            if snippet:
                doc.add_paragraph()
                doc.add_paragraph("Source Snippet:")
                doc.add_paragraph(snippet)

    # tables (optional)
    doc.add_paragraph()
    doc.add_heading("Tables", level=1)

    tables = getattr(run, "tables", None) or []
    if not tables:
        doc.add_paragraph("No tables found.")
    else:
        for t in tables:
            title = safe_text(getattr(t, "title", "")) or "Table"
            cols = getattr(t, "columns", None) or []
            rows_json = getattr(t, "rows_json", None) or []

            # rows_json might be list[dict] or list[list]
            if rows_json and isinstance(rows_json[0], dict):
                # build columns from dict keys if columns missing
                if not cols:
                    cols = list(rows_json[0].keys())
                rows = [[r.get(c, "") for c in cols] for r in rows_json]
            else:
                rows = rows_json

            add_simple_table(doc, title=title, columns=[safe_text(c) for c in cols], rows=rows)

    # 5) Save to temp file and return FileResponse (like your working export code)
    filename = f"report_{doc_id}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.docx"
    tmp = tempfile.NamedTemporaryFile(delete=False, suffix=".docx")
    tmp_path = tmp.name
    tmp.close()

    doc.save(tmp_path)

    background_tasks.add_task(cleanup_file, tmp_path)

    return FileResponse(
        tmp_path,
        media_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        filename=filename,
        headers={
            # helps some browsers
            "Content-Disposition": f'attachment; filename="{filename}"'
        }
    )



downloadReport: async (docId: string) => {
  const res = await api.get(`/documents/${docId}/report`, {
    responseType: "arraybuffer",
  });

  const blob = new Blob([res.data], {
    type: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  });

  const url = window.URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;

  const cd = res.headers["content-disposition"];
  const match = cd?.match(/filename="(.+?)"/);
  a.download = match?.[1] || `report_${docId}.docx`;

  document.body.appendChild(a);
  a.click();
  a.remove();
  window.URL.revokeObjectURL(url);
},
