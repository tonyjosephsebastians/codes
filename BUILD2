#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
build_indexes.py â€” index only PROC and JCL (no SAS).
Outputs:
  - procs_index.csv
  - jcl_index.csv
"""

import os, re, io, csv, glob
from concurrent.futures import ProcessPoolExecutor, as_completed

BASE = os.getcwd()
PROC_DIR  = os.path.join(BASE, "proc")
JCL_DIR   = os.path.join(BASE, "jcl")

OUT_PROCS = os.path.join(BASE, "procs_index.csv")
OUT_JCL   = os.path.join(BASE, "jcl_index.csv")

IDENT = r"[A-Z0-9][A-Z0-9\-_]*"

def read_text(p):
    with io.open(p, "r", encoding="utf-8", errors="ignore") as f:
        return f.read()

def norm(s):
    import re
    return re.sub(r"\s+","",s.upper()) if isinstance(s,str) else s

def dsn_tail(dsn: str, keep_parts: int = 3) -> str:
    if not dsn: return ""
    s = dsn.upper()
    s = re.sub(r"\.+", ".", s.strip("."))
    parts = s.split(".")
    if len(parts) <= keep_parts:
        return s
    return ".".join(parts[-keep_parts:])

def kv_from_dd_tail(tail: str) -> dict:
    d = {}
    for key in ["DSN","DSNAME","DISP","UNIT","SPACE","VOL"]:
        m = re.search(rf"\b{key}\s*=\s*([^,]+)", tail, re.I)
        if m:
            d[key] = m.group(1).strip()
    m = re.search(r"DCB\s*=\s*\(([^)]*)\)", tail, re.I)
    if m:
        dcb = m.group(1)
        for key in ["RECFM","LRECL","BLKSIZE"]:
            m2 = re.search(rf"\b{key}\s*=\s*([A-Z0-9]+)", dcb, re.I)
            if m2: d[key] = m2.group(1)
    if "DSN" not in d and "DSNAME" in d:
        d["DSN"] = d["DSNAME"]
    return d

RE_EXEC = re.compile(rf"^\s*//({IDENT})?\s*EXEC\b\s+([A-Z0-9=,()'\"/ +\-]+)", re.I)
RE_DD   = re.compile(rf"^\s*//({IDENT})\s+DD\b\s+(.*)$", re.I)

def parse_exec_pgm(execspec: str) -> str:
    if not execspec: return ""
    m = re.search(r"\bPGM\s*=\s*([A-Z0-9$#@]+)", execspec, re.I)
    if m: return m.group(1).upper()
    head = execspec.strip().split(",")[0].strip().upper()
    return head

def index_jcl_like_one(path):
    rows=[]
    step=""; execspec=""
    for ln, line in enumerate(read_text(path).splitlines(), 1):
        if line.strip().startswith("//*"):
            continue
        m = RE_EXEC.match(line)
        if m:
            step = (m.group(1) or "").upper()
            execspec = m.group(2)
        m = RE_DD.match(line)
        if m:
            dd = m.group(1).upper()
            tail = m.group(2)
            kv = kv_from_dd_tail(tail)
            dsn = (kv.get("DSN","") or "").upper()
            rows.append({
                "file": path, "line": ln, "step": step,
                "exec": execspec, "exec_pgm": parse_exec_pgm(execspec),
                "ddname": dd,
                "dsn": dsn,
                "dsn_tail": dsn_tail(dsn, keep_parts=3),
                "disp": kv.get("DISP",""),
                "recfm": kv.get("RECFM",""),
                "lrecl": kv.get("LRECL",""),
                "blksize": kv.get("BLKSIZE",""),
                "raw": tail.strip()
            })
    return rows

def write_csv(path, fieldnames, rows):
    with io.open(path,"w",newline="",encoding="utf-8") as f:
        w=csv.DictWriter(f, fieldnames=fieldnames)
        w.writeheader(); [w.writerow(r) for r in rows]

def collect_files(root, exts):
    return [p for p in glob.glob(os.path.join(root,"**/*"), recursive=True)
            if os.path.isfile(p) and p.upper().endswith(exts)]

def main():
    os.makedirs(PROC_DIR, exist_ok=True)
    os.makedirs(JCL_DIR,  exist_ok=True)

    proc_files = collect_files(PROC_DIR, (".JCL",".PROC",".PRC",".CNTL",".TXT"))
    jcl_files  = collect_files(JCL_DIR,  (".JCL",".CNTL",".TXT"))

    prows=[]; jrows=[]

    with ProcessPoolExecutor() as ex:
        futs = {ex.submit(index_jcl_like_one, p): ("PROC", p) for p in proc_files}
        futs.update({ex.submit(index_jcl_like_one, p): ("JCL", p) for p in jcl_files})
        for fut in as_completed(futs):
            kind, _ = futs[fut]
            rows = fut.result()
            if kind=="PROC": prows.extend(rows)
            else: jrows.extend(rows)

    headers = ["file","line","step","exec","exec_pgm","ddname","dsn","dsn_tail","disp","recfm","lrecl","blksize","raw"]
    write_csv(OUT_PROCS, headers, prows)
    write_csv(OUT_JCL,   headers, jrows)
    print(f"Wrote {OUT_PROCS} ({len(prows)}), {OUT_JCL} ({len(jrows)})")

if __name__ == "__main__":
    main()
