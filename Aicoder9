from io import BytesIO
from datetime import datetime
from fastapi import APIRouter, Depends, HTTPException
from fastapi.responses import Response
from docx import Document as DocxDocument
from docx.shared import Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH

# router = APIRouter(prefix="/documents", tags=["documents"])  # keep this

@router.get("/{doc_id}/report")  # ✅ IMPORTANT
def generate_docx_report(
    doc_id: str,
    db: Session = Depends(get_db),
    current_user=Depends(get_current_user),
):
    # 1) Find document
    doc_obj = db.query(Document).filter(Document.id == doc_id).first()
    if not doc_obj:
        raise HTTPException(status_code=404, detail="Document not found")

    # 2) Permissions
    if current_user.role.value not in ["admin", "superuser"] and doc_obj.uploaded_by != current_user.username:
        raise HTTPException(status_code=403, detail="Not authorized to access this document")

    # 3) Latest completed extraction run
    run = _get_latest_completed_run(
        db=db,
        document_id=doc_id,
        username=doc_obj.uploaded_by,
        standard="SOC2",
    )
    if not run:
        raise HTTPException(status_code=404, detail="No completed extraction run found")

    payload = _format_extraction_run_response(run)
    if not payload:
        raise HTTPException(status_code=500, detail="Run serialization missing")

    # 4) Build DOCX
    d = DocxDocument()

    title = d.add_paragraph()
    tr = title.add_run("Document Analysis Report")
    tr.bold = True
    tr.font.size = Pt(16)
    title.alignment = WD_ALIGN_PARAGRAPH.CENTER

    meta = payload.get("extraction_run", {}) or {}
    d.add_paragraph(f"Document: {getattr(doc_obj, 'original_filename', '') or doc_id}")
    d.add_paragraph(f"Standard: {meta.get('standard', '')}")
    d.add_paragraph(f"Pipeline: {meta.get('pipeline_version', '')}")
    d.add_paragraph(f"Completed: {meta.get('completed_at', '')}")
    d.add_paragraph("")

    # (Optional) TODO: add your fields/tables here after this basic file opens

    # 5) Return bytes (not streaming)
    buf = BytesIO()
    d.save(buf)
    doc_bytes = buf.getvalue()

    # ✅ sanity check: DOCX is a ZIP, must start with PK
    if not doc_bytes.startswith(b"PK"):
        raise HTTPException(status_code=500, detail="Generated output is not a valid DOCX (missing PK header)")

    filename = f"report_{doc_id}_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.docx"
    return Response(
        content=doc_bytes,
        media_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        headers={
            "Content-Disposition": f'attachment; filename="{filename}"',
            "Cache-Control": "no-store",
        },
    )


downloadReport: async (docId: string) => {
  const res = await api.get(`/documents/${docId}/report`, { responseType: "blob" });

  const blob = res.data; // ✅ already a Blob
  const url = window.URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;

  const cd = res.headers["content-disposition"];
  const match = cd?.match(/filename="(.+?)"/);
  a.download = match?.[1] || `report_${docId}.docx`;

  document.body.appendChild(a);
  a.click();
  a.remove();
  window.URL.revokeObjectURL(url);
}


