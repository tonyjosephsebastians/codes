import React, { useEffect, useRef, useState } from "react";
import { Loader2 } from "lucide-react";
import { renderAsync } from "docx-preview";
import { aiCompareApi } from "@/services/api";

interface WordDocumentPreviewProps {
  file?: File;
  fileUrl?: string;
  arrayBuffer?: ArrayBuffer;
  baselineArrayBuffer?: ArrayBuffer | null;
  fileName?: string;
  onScroll?: (scrollTop: number, scrollLeft: number) => void;
  scrollTop?: number;
  scrollLeft?: number;
  syncScroll?: boolean;
  showDiff?: boolean;
  activeClauseReference?: string | null;
}

const WordDocumentPreview: React.FC<WordDocumentPreviewProps> = ({
  file,
  fileUrl,
  arrayBuffer,
  baselineArrayBuffer,
  fileName,
  onScroll,
  scrollTop = 0,
  scrollLeft = 0,
  syncScroll = false,
  showDiff = false,
  activeClauseReference = null,
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const scrollContainerRef = useRef<HTMLDivElement>(null);
  const isSyncingRef = useRef(false);
  const isRenderingRef = useRef(false);

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  /* -------------------------------------------------- */
  /* Helpers                                            */
  /* -------------------------------------------------- */

  const normalize = (t: string) =>
    t
      .toLowerCase()
      .replace(/\s+/g, " ")
      .replace(/[^\w\s().,-]/g, "")
      .trim();

  const toBase64 = (buf: ArrayBuffer) =>
    btoa(String.fromCharCode(...new Uint8Array(buf)));

  async function fetchWordDiff(
    baseline: ArrayBuffer,
    revised: ArrayBuffer
  ) {
    const res = await aiCompareApi.compareDocuments(
      toBase64(baseline),
      toBase64(revised)
    );

    if (!res?.diff_docx_b64) {
      throw new Error("Invalid diff response");
    }

    return Uint8Array.from(atob(res.diff_docx_b64), c =>
      c.charCodeAt(0)
    ).buffer;
  }

  /* -------------------------------------------------- */
  /* Render DOCX                                        */
  /* -------------------------------------------------- */

  useEffect(() => {
    let mounted = true;

    const renderDocument = async () => {
      if (isRenderingRef.current || !containerRef.current) return;
      isRenderingRef.current = true;

      try {
        setLoading(true);
        setError(null);

        let data: ArrayBuffer | undefined;

        if (arrayBuffer) data = arrayBuffer;
        else if (file) data = await file.arrayBuffer();
        else if (fileUrl) {
          const r = await fetch(fileUrl);
          data = await r.arrayBuffer();
        }

        if (!data) return;

        containerRef.current.innerHTML = "";

        const wrapper = document.createElement("div");
        wrapper.className = "docx-wrapper";
        containerRef.current.appendChild(wrapper);

        let renderBuffer = data;

        if (showDiff && baselineArrayBuffer && arrayBuffer) {
          renderBuffer = await fetchWordDiff(
            baselineArrayBuffer,
            arrayBuffer
          );
        }

        await renderAsync(renderBuffer, wrapper, undefined, {
          breakPages: true,
          ignoreWidth: false,
          ignoreHeight: false,
          renderHeaders: true,
          renderFooters: true,
          renderEndnotes: true,
        });

        /* ---------- Remove DOCX shadows ---------- */
        const style = document.createElement("style");
        style.textContent = `
          section.docx {
            box-shadow: none !important;
            border: none !important;
            background: white !important;
          }
          .docx-wrapper {
            background: white !important;
            padding: 0 !important;
          }
          .active-clause {
            background: rgba(255, 235, 59, 0.45);
          }
        `;
        containerRef.current.appendChild(style);
      } catch (e: any) {
        setError(e.message || "Failed to render document");
      } finally {
        setLoading(false);
        isRenderingRef.current = false;
      }
    };

    renderDocument();

    return () => {
      mounted = false;
      if (containerRef.current) containerRef.current.innerHTML = "";
    };
  }, [arrayBuffer, baselineArrayBuffer, showDiff, fileUrl]);

  /* -------------------------------------------------- */
  /* Clause Scroll (FIXED)                              */
  /* -------------------------------------------------- */

  useEffect(() => {
    if (
      !activeClauseReference ||
      !containerRef.current ||
      !scrollContainerRef.current
    )
      return;

    const targetText = normalize(activeClauseReference);
    const paragraphs = Array.from(
      containerRef.current.querySelectorAll("p, li, td")
    );

    const match = paragraphs.find(p =>
      normalize(p.textContent || "").includes(targetText)
    );

    if (!match) {
      console.warn("Clause not found:", activeClauseReference);
      return;
    }

    // Remove old highlight
    containerRef.current
      .querySelectorAll(".active-clause")
      .forEach(el => el.classList.remove("active-clause"));

    match.classList.add("active-clause");

    // ✅ CRITICAL FIX: offsetTop-based scroll
    const scrollContainer = scrollContainerRef.current;

    scrollContainer.scrollTo({
      top:
        match.offsetTop -
        scrollContainer.offsetTop -
        80,
      behavior: "smooth",
    });
  }, [activeClauseReference]);

  /* -------------------------------------------------- */
  /* Sync Scroll                                        */
  /* -------------------------------------------------- */

  useEffect(() => {
    if (!syncScroll || !scrollContainerRef.current || isSyncingRef.current)
      return;

    isSyncingRef.current = true;

    requestAnimationFrame(() => {
      if (!scrollContainerRef.current) return;
      scrollContainerRef.current.scrollTop = scrollTop;
      scrollContainerRef.current.scrollLeft = scrollLeft;

      setTimeout(() => {
        isSyncingRef.current = false;
      }, 16);
    });
  }, [scrollTop, scrollLeft, syncScroll]);

  const handleScroll = (e: React.UIEvent<HTMLDivElement>) => {
    if (isSyncingRef.current || !onScroll) return;
    const t = e.currentTarget;
    onScroll(t.scrollTop, t.scrollLeft);
  };

  /* -------------------------------------------------- */
  /* UI                                                 */
  /* -------------------------------------------------- */

  return (
    <div className="flex flex-col h-full bg-white">
      {loading && (
        <div className="flex flex-col items-center justify-center h-full">
          <Loader2 className="h-10 w-10 animate-spin text-[#007C41]" />
          <p className="text-sm text-gray-600 mt-2">Loading document…</p>
        </div>
      )}

      {error && (
        <div className="flex flex-col items-center justify-center h-full">
          <p className="text-red-600 font-semibold">Error rendering document</p>
          <p className="text-sm text-gray-500">{error}</p>
        </div>
      )}

      <div
        ref={scrollContainerRef}
        className="flex-1 overflow-auto bg-gray-50"
        onScroll={handleScroll}
      >
        <div
          ref={containerRef}
          className={`docx-container ${loading || error ? "hidden" : ""}`}
          style={{ minHeight: "100%", width: "100%" }}
        />
      </div>

      {fileName && (
        <div className="text-xs text-gray-500 text-center border-t p-1">
          {fileName}
        </div>
      )}
    </div>
  );
};

export default WordDocumentPreview;
