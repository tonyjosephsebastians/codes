import React, { useEffect, useState, useRef, useMemo } from "react";
import { FileText, X, Search } from "lucide-react";
import type { ParsedDocument } from "@/utils/documentParser";
import WordDocumentPreview from "./WordDocumentPreview";

interface DocumentViewerProps {
  doc: string;
  title: string;
  parsedDocument: ParsedDocument | null;
  file: File | null;
  fileUrl: string;
  onScroll: (scrollTop: number, scrollLeft: number) => void;
  scrollTop: number;
  scrollLeft: number;
  syncScroll: boolean;
  onFileRemove: () => void;
  showDiff: boolean;
  baselineArrayBuffer?: ArrayBuffer | null;
  htmlContent?: string | null;
}

const DocumentViewer = ({
  doc,
  title,
  parsedDocument,
  file,
  fileUrl,
  onScroll,
  scrollTop = 0,
  scrollLeft = 0,
  syncScroll = false,
  onFileRemove,
  showDiff = false,
  baselineArrayBuffer = null,
  htmlContent = null,
}: DocumentViewerProps) => {
  const [searchTerm, setSearchTerm] = useState("");
  const [matches, setMatches] = useState<HTMLElement[]>([]);
  const [currentMatchIndex, setCurrentMatchIndex] = useState(0);
  const [pageCount, setPageCount] = useState(0);
  const [currentPage, setCurrentPage] = useState(1);
  const containerRef = useRef<HTMLDivElement>(null);

  /* --------------------------------------------
     Reset search when document changes or diff toggled
  -------------------------------------------- */
  useEffect(() => {
    setSearchTerm("");
    setMatches([]);
    setCurrentMatchIndex(0);
  }, [parsedDocument, showDiff]);

  /* --------------------------------------------
     Page tracking (optional)
  -------------------------------------------- */
  useEffect(() => {
    if (!containerRef.current) return;
    const container = containerRef.current;
    const pages = container.querySelectorAll("section.docx");
    setPageCount(pages.length);

    const handleScroll = () => {
      const scrollTop = container.scrollTop;
      let current = 1;
      pages.forEach((page, idx) => {
        const el = page as HTMLElement;
        if (el.offsetTop - 200 < scrollTop) current = idx + 1;
      });
      setCurrentPage(current);
    };

    container.addEventListener("scroll", handleScroll);
    return () => container.removeEventListener("scroll", handleScroll);
  }, [parsedDocument]);

  /* --------------------------------------------
     Search and Highlight Logic
  -------------------------------------------- */

  const escapeRegExp = (s: string) => s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

  const handleSearch = (query: string) => {
    setSearchTerm(query);
    if (!containerRef.current) return;

    // 1️⃣ Clear previous highlights
    containerRef.current.querySelectorAll("mark.highlight").forEach((mark) => {
      const parent = mark.parentNode;
      if (parent)
        parent.replaceChild(document.createTextNode(mark.textContent || ""), mark);
    });

    // 2️⃣ Stop if empty
    if (!query.trim()) {
      setMatches([]);
      setCurrentMatchIndex(0);
      return;
    }

    // 3️⃣ Case-insensitive regex
    const pattern = escapeRegExp(query);
    const regex = new RegExp(pattern, "gi");
    const walker = document.createTreeWalker(containerRef.current, NodeFilter.SHOW_TEXT);
    const found: HTMLElement[] = [];

    // 4️⃣ Walk all text nodes
    while (walker.nextNode()) {
      const node = walker.currentNode as Text;
      const parent = node.parentElement;
      if (!parent) continue;

      // Skip diff markup spans
      if (
        parent.classList.contains("word-insert") ||
        parent.classList.contains("word-delete")
      ) {
        continue;
      }

      const text = node.nodeValue || "";
      regex.lastIndex = 0; // reset for each node
      if (!regex.test(text)) continue;

      // Replace matches
      const span = document.createElement("span");
      span.innerHTML = text.replace(
        new RegExp(pattern, "gi"),
        (m) => `<mark class="highlight">${m}</mark>`
      );
      parent.replaceChild(span, node);

      span.querySelectorAll("mark.highlight").forEach((el) =>
        found.push(el as HTMLElement)
      );
    }

    // 5️⃣ Store results
    setMatches(found);
    setCurrentMatchIndex(0);

    // 6️⃣ Focus first match
    if (found.length) {
      found[0].classList.add("current");
      found[0].scrollIntoView({ behavior: "smooth", block: "center", inline: "nearest" });
    }
  };

  /* --------------------------------------------
     Navigation (Next / Previous)
  -------------------------------------------- */

  const focusMatch = (idx: number) => {
    if (!matches.length) return;
    matches.forEach((m) => m.classList.remove("current"));
    const el = matches[idx];
    el.classList.add("current");
    el.scrollIntoView({ behavior: "smooth", block: "center", inline: "nearest" });
  };

  const goNext = () => {
    if (!matches.length) return;
    const next = (currentMatchIndex + 1) % matches.length;
    setCurrentMatchIndex(next);
    focusMatch(next);
  };

  const goPrev = () => {
    if (!matches.length) return;
    const prev = (currentMatchIndex - 1 + matches.length) % matches.length;
    setCurrentMatchIndex(prev);
    focusMatch(prev);
  };

  useEffect(() => {
    if (matches.length && matches[currentMatchIndex]) {
      focusMatch(currentMatchIndex);
    }
  }, [currentMatchIndex, matches]);

  /* --------------------------------------------
     Render
  -------------------------------------------- */
  return (
    <div className="h-full flex flex-col rounded-lg overflow-hidden">
      {/* Top Bar */}
      <div className="flex items-center justify-between p-3 border-b border-gray-200 bg-gray-50 rounded-t-lg">
        <div className="flex items-center space-x-2">
          <FileText className="h-4 w-4 text-gray-600" />
          <span className="text-sm font-medium text-gray-900">{title}</span>
        </div>

        <div className="flex items-center space-x-2">
          <input
            type="text"
            value={searchTerm}
            onChange={(e) => handleSearch(e.target.value)}
            placeholder="Search in document..."
            onKeyDown={(e) => e.key === "Enter" && goNext()}
            className="border rounded px-2 py-1 text-sm"
          />

          <button
            className="px-2 py-1 border rounded text-sm"
            onClick={goPrev}
            disabled={!matches.length}
          >
            Prev
          </button>
          <button
            className="px-2 py-1 border rounded text-sm"
            onClick={goNext}
            disabled={!matches.length}
          >
            Next
          </button>
          <span className="text-xs text-gray-500">
            {matches.length ? `${currentMatchIndex + 1}/${matches.length}` : "0/0"}
          </span>

          {onFileRemove && (
            <button
              onClick={onFileRemove}
              className="text-gray-400 hover:text-red-500 transition-colors"
              title="Remove Document"
            >
              <X className="h-4 w-4" />
            </button>
          )}
        </div>
      </div>

      {/* Document Container */}
      <div
        ref={containerRef}
        className="flex-1 overflow-auto p-2 bg-gray-50"
        style={{ scrollBehavior: "smooth" }}
      >
        {file || parsedDocument?.originalContent ? (
          <WordDocumentPreview
            file={file || undefined}
            arrayBuffer={parsedDocument?.originalContent || null}
            fileName={parsedDocument?.metadata?.title || ""}
            onScroll={onScroll}
            scrollTop={scrollTop}
            scrollLeft={scrollLeft}
            syncScroll={syncScroll}
            showDiff={showDiff}
            baselineArrayBuffer={baselineArrayBuffer}
            htmlContent={parsedDocument?.html || ""}
          />
        ) : (
          <div className="flex-1 flex items-center justify-center text-gray-500">
            <p>No document content available.</p>
          </div>
        )}
      </div>

      {/* Page indicator */}
      <div className="absolute bottom-2 right-4 bg-white/80 px-3 py-1 border rounded text-xs text-gray-600 shadow">
        Page {currentPage}/{pageCount || 1}
      </div>

      {/* Inline CSS for highlights */}
      <style>{`
        mark.highlight {
          background-color: #fff59d;
          color: #000;
          border-radius: 2px;
          padding: 0 2px;
          transition: background-color 0.2s ease;
        }
        mark.highlight.current {
          outline: 2px solid #f39c12;
          background-color: #ffeb3b;
        }
      `}</style>
    </div>
  );
};

export default DocumentViewer;
